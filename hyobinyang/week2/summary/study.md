# 추가 학습: 컨테이너의 이해

## VM  vs  컨테이너
### 하이퍼바이저란?

- **정의**: 물리 하드웨어 위에서 여러 개의 가상 머신(VM)을 실행·관리하는 소프트웨어 계층(하드웨어를 가상화해 VM을 실행·관리하는 중간 계층)
- **역할**:
    - CPU, 메모리, 디스크, 네트워크 같은 자원을 가상화해서 VM에게 분배
    - VM은 자신이 **마치 독립적인 물리 서버처럼** 동작한다고 믿음

### “VM은 동일 하이퍼바이저 간에만 이식된다”는 의미

- VM을 옮길 때는 **하이퍼바이저가 이해할 수 있는 VM 포맷**이어야 함
- 각 하이퍼바이저는 VM의 **메타데이터, 가상 디바이스(디스크, 네트워크, 그래픽), 드라이버**를 다르게 표현합

→ 따라서 **같은 하이퍼바이저끼리는 그대로 옮겨 실행 가능**하지만, 다른 하이퍼바이저로는 바로 못 돌림

→ 이식하려면 변환 도구(예: qemu-img로 디스크 포맷 변환)가 필요

즉

- VM은 **하드웨어 전체를 가상화**해서 그 위에 완전한 운영체제(OS)를 올림
- 각 VM마다 **커널 포함 OS 전체**가 필요
- 그래서 VM을 로컬에 옮기면 → **게스트 OS 커널까지 그대로 가져와서 실행**
- 결과적으로, 내 PC(호스트 OS)가 macOS든 Windows든 상관없이, VM은 자기 커널(Ubuntu, CentOS 등)을 쓰기 때문에 독립적으로 동작

```
[하드웨어] ─ [하이퍼바이저] ─ [게스트 OS(커널 포함)] ─ [앱]
```

- 장점: 완전히 격리, 이식성 높음.
- 단점: 무겁고 리소스 많이 필요 (OS를 VM마다 깔아야 하니까)

## 컨테이너

- 컨테이너는 **호스트의 커널을 공유** (내 로컬 커널!! - 리눅스라면 cgroups, namespace로 격리)
- 내 PC의 리눅스 커널을 빌려 쓰는 거

⇒ 리눅스 컨테이너는 반드시 리눅스 커널 위에서만 실행 가능 - Docker Desktop이 **내부적으로 리눅스 VM**을 띄워줌

- 이미지에는 **애플리케이션 + 런타임 + 라이브러리**만 들어 있고 **커널은 없음**.
- 구조:
```
[하드웨어] ─ [호스트 OS(커널)] ─ [컨테이너 런타임] ─ [앱 + 라이브러리]
```
- 장점: 훨씬 가볍고 빠르게 실행됨.
- 단점: 호스트와 커널이 같아야 함 (예: 리눅스 컨테이너는 리눅스 커널 필요)

## 컨테이너 표준 도구: Docker

도커(Docker)
- 컨테이너 기술을 지원하는 다양한 플랫폼 중에 하나
- 컨테이너 기술은 이전에도 있었으나 도커로 인해 알려짐
- 컨테이너 기술의 사실상 표준
- 다양한 운영체제에서 사용 가능(리눅스, 윈도우, MacOS)
- 애플리케이션에 국한 되지 않고 의존성 및 파일 시스템까지 패키징하여 빌드, 배포, 실행을 단순화
- 리눅스의 네임 스페이스와 cgroup와 같은 커널 기능을 사용하여 가상화

### Container Feature
```
Docker 데몬 → runC → namespace, cgroup → container 생성
```

- **Namespaces**: PID, 네트워크, 파일시스템, 사용자 등 리소스를 분리해 컨테이너마다 독립된 환경처럼 보이게 함.
- **cgroups**: CPU, 메모리, 디스크 I/O 같은 자원 사용량을 제한하고 관리함.
- **AppArmor / SELinux**: 컨테이너 프로세스가 접근할 수 있는 파일·시스템 리소스를 정책으로 제어하는 보안 모듈.
- **seccomp**: 컨테이너가 호출할 수 있는 시스템 콜을 제한해 보안을 강화함.
- **chroot**: 컨테이너 프로세스가 볼 수 있는 루트 디렉토리를 바꿔서 파일시스템을 격리함.

---

#### Docker Engine 는 containerd 를 관리
- containerd는 container 생성 시 container-shim 경량 프로세스 생성
- container-shim은 컨테이너 내 프로세스를 생성하거나 관리 (with runC)
- container는 프로세스들을 격리하기 위한 단위

`Docker Engine`
- Doker의 진입점
- Docker 이미지, 오케스트레이션, 볼륨관리, 네트워킹 확장 등을 담당
- Docker 엔진에 이미지 실행을 요청하면 containerd 데몬에 책임을 위임

`Containerd`
- 컨테이너 이미지를 저장하고 전송
- 루트 파일시스템을 만들고
- runC호출하여 컨테이너를 시작
- 컨테이너 관리
- 저수준의 스토리지와 네트워크 인터페이스 관리

`runC`
- 컨테이너의 실행 시작을 담당하는 프로세스.
- libcontainer의 리팩토링 구현체.


## 도커 자원의 가상화

`프로세스 테이블`
- 컨테이너마다 별도의 프로세스 테이블을 관리
- 특정 컨테이너의 프로세스에서 다른 컨테이너의 프로세스로 접근할 수 없음

`CPU, 메모리 장치 ( “/dev”다음 장치 파일)`
- 컨테이너에서 사용할 수있는 범위를 제한

`파일 시스템`
- 컨테이너마다 특정 디렉토리를 루트 파일 시스템으로 보이게 함.

`네트워크`
- 네트워크 네임 스페이스 (netns)의 기능으로 컨테이너마다 별도의 네트워크 설정 구성.
- veth라는 가상 NIC 장치를 이용하여 veth의 한쪽을 컨테이너 내부 네임 스페이스에 할당